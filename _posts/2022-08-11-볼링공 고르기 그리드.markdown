---
title: 볼링 공 고르기 그리드
date:   2022-08-11 20:38:41 +0900
categories: [Coding_Test, Others]
tags: [coding, python, algorithm, greedy]
---

> A, B 두 사람이 볼링을 치고 있습니다. 두 사람은 서로 무게가 다른 볼링 공을 고르려고 합니다. 볼링공은 총 N개가 있으며 각 볼링공마다 무게가 적혀 있고 공의 번호는 1번부터 순서대로 부여됩니다. 같은 무게의 공이 여러개 있을 수 있지만 서로 다른 공으로 간주합니다. 볼링공의 무게는 1부터 M까지의 자연수 형태로 존재합니다.
> 
> N이 5번이고 M이 3이며 각각의 무게가 차례대로 1,3,2,3,2일때 공의 번호가 차례대로 1번부터 5번까지 부여됩니다. 두 사람이 고를 수 있는 볼링공 번호의 조합을 구하면 경우의 수를 구하시오


사실 나에게 있어서 문제가 직관적이지 않아서 이해를 하지 못했다. 볼링공의 개수는 이해를 하겠는데 공의 최대 무게를 왜 다시 입력받는지이다. 결국 무게를 입력받는데 입력받는 무게에서 최대 값이 곳 M을 결정하는게 아닌가? 단순하게 combination조합으로 5가지를 돌려보면 10가지이지만 정답으로는 8을 제시했는데 이 역시 바로 이해하지 못했다.


그러니까 공의 개수는 N개가 주어지고 각 숫자는 공의 무게가 되고 선택을 했을때 공의 무게는 M을 넘어서는 안된다. 

 
> 예시  
> 무게가 1인 볼링공 1개  
> 무게가 2인 볼링공 2개  
> 무게가 3인 볼링공 2개  
>  
> A가 어떤 볼링공을 선택했다면 이어서 B가 볼링공을 선택하는 경우를 차례대로 계산해보자  
> 1. A가 1인 공을 선택할때 개수는  
> 1(무게가 1) x 4(B가 선택하는 경우의 수) = 4가지 경우  
> (이거는 이해가 된다. 1을 선택하면 남는거는 2인 볼링공 2개 3인 볼링공 2개가 되니)  
> 2(무게가 2) x 2(B가 선택하는 경우의 수) = 4가지 경우  
> 3(무게가 3) x 0(이미 앞에서 모든 경우의 수를 챙겨갔다)  

그래서 8

... 그냥 조합문제였고 같은 무게만 고르지 않으면 된다.

```py
n, m = map(int, input().split())
num_list = list(map(int,input().split()))

A = list(combinations(num_list,2))

result = []
for i in range(len(A)):
    if A[i][0] != A[i][1]:
        result.append(A[i])
        
print(len(result))
```

이번에도 내장함수인 조합을 가져와서 같은 무게를 선택하는 경우를 빼는 걸로 간단하게 풀었다.

![time elapsed](https://user-images.githubusercontent.com/85277660/210985697-906ab9c8-0405-4904-9ab9-f1c092d8cea8.png)

정답코드를 보자

```py
n,m = map(int,input().split())
data = list(map(int,input().split()))

#1부터 10까지의 무게를 담을 수 있는 리스트
array = [0] * 11
for x in data:
    #각 무게에 해당하는 볼링공의 개수 카운트
    array[x] += 1

result = 0
#1부터 m까지의 각 무게에 대하여 처리
for i in range(1,m+1):
    n -= array[i]
    #무게가 1인 볼링공의 개수(A가 선택할 수 있는 개수) 제외
    result += array[i] * n #B가 선택하는 경우의 수와 곱하기
    
print(result)
```

볼링공의 무개는 10까지 제한되어 있는데 계산의 편의를 위해서 총 11칸을 만들었다. 0번칸은 비운다.

각 무게에 대해서 처리를 하는데 1*4, 2*2, 3*0 이런식으로 하나씩 빠진다.

![totla reuslt](https://user-images.githubusercontent.com/85277660/210986456-ff920960-1f23-4e48-a2c8-b03ca9d91518.png)

콤비네이션 내장 함수쓰는게 시간이 보다 적게 소요된다.